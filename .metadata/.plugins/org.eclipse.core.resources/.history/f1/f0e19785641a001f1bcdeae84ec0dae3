package practice;

public class codingtest_1 
{


	public static void main(String[] args) 
	{
		/*
		 *  배열 조작
			문제: 정수 배열이 주어지면, 배열의 각 요소를 두 배로 만든 새로운 배열을 반환하세요.
			예시 입력: [1, 2, 3, 4, 5]
			예시 출력: [2, 4, 6, 8, 10]
		 * 
		 */
		
		// 도현_1차적으로 내가 푼 문제
		int[] test = new int[] {1,2,3,4,5};
		
		for(int i = 0; i < test.length; i++) 
		{
			System.out.print( test[i] * 2);
		}
		
		// 도현_gpt가 아렬준 답
		
		int[] arr = new int[] {1,2,3,4,5};
		int[] result = new int[test.length];
		
		for(int i = 0; i < arr.length; i++) 
		{
			result[i] = arr[i] * 2;
		}
		for(int i : result) 
		{
			   System.out.print(i + " ");
		}
		
		System.out.println("1번 끝 ======================================");

		/*
		 * gpt 1번 문제
		 * 정수로 이루어진 배열과 정수 target이 주어집니다.
		 * 배열 안에서 두 수를 더하여 target이 되는 두 수의 인덱스를 찾아 해당 인덱스를 반환하는 함수를 작성하세요. 
		 * 단, 같은 요소는 두 번 사용할 수 없습니다.
		 */
		
		// 도현_ 첫 번째 답
		String test_2 = "racecar";


		if(test_2 == "racecar") 
		{
			System.out.println("일치합니다 " + "True");
		}
		else
		{
			System.out.println("불일치 : " + false);
		}
		
		// 도현_ gpt 답
		
		System.out.println("2번 끝 ======================================");
		
		/*
		 * 문제: 이진 트리(Binary Tree)에서 주어진 값의 모든 노드를 찾는 함수를 구현하세요.
		 */
		
		// 도현_객체 생성 후 변수의 값을 계속 바꿔주기
		TreeNode tn = new TreeNode(5);
		tn.left = new TreeNode(3);
		tn.right = new TreeNode(7);
		tn.left.left = new TreeNode(1);
		tn.left.right = new TreeNode(3);
		tn.right.left = new TreeNode(6);
		tn.right.right = new TreeNode(8);
		
		// 도현_주어진 값과 일치하는 노드 찾기
		int target = 3;
		TreeNode[] result_1 = tn.findNodes(tn, target);
		
		// 도현_결과출력
		System.out.println("여기서 확인하기 : " + result_1);
		for(TreeNode root : result_1) 
		{
			System.out.println(root.val + " ");
		}
		
		/*
		 * 두 개의 정렬된 배열이 주어졌을 때, 이 두 배열을 하나의 정렬된 배열로 합치는 함수를 작성하세요
		 * */
		
		// 도현_변수 선언
		int[] arr_1 = new int[] {1,3,5};
		
	}

}
